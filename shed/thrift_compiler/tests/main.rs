/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This software may be used and distributed according to the terms of the
 * GNU General Public License found in the LICENSE file in the root
 * directory of this source tree.
 */

use std::env;
use std::fs;
use std::path::Path;
use std::sync::{Arc, Mutex};

use anyhow::{Context, Result};
use lazy_static::lazy_static;
use regex::{escape, Regex};
use tempdir::TempDir;

use thrift_compiler::Config;

lazy_static! {
    static ref ENV_SET: Arc<Mutex<()>> = Arc::new(Mutex::new(()));
}

fn run_thrift(
    input_files: &[impl AsRef<Path>],
    cratemap: Option<&str>,
    files: &[(impl AsRef<Path>, impl AsRef<str>)],
) -> Result<String> {
    let temp_dir =
        TempDir::new(concat!("test", module_path!())).context("Failed to create temp dir")?;
    let temp_dir: &Path = temp_dir.as_ref();
    let input_dir = temp_dir.join("input");
    fs::create_dir(&input_dir).context("Failed to create temp input dir")?;
    let out_dir = temp_dir.join("out");
    fs::create_dir(&out_dir).context("Failed to create temp out dir")?;

    if let Some(cratemap) = cratemap {
        fs::write(out_dir.join("cratemap"), cratemap)
            .context("Failed writing cratemap to out dir")?;
    }

    for (file, content) in files {
        let file = file.as_ref();
        let content = content.as_ref();
        if let Some(parent) = file.parent() {
            fs::create_dir_all(input_dir.join(&parent))
                .with_context(|| format!("Failed creating input subdir '{}'", parent.display()))?;
        }
        fs::write(input_dir.join(&file), content)
            .with_context(|| format!("Failed writing file inside input '{}'", file.display()))?;
    }

    let mut compiler = {
        let _lock_on_env_mutation = ENV_SET.lock().expect("Poisoned lock");

        env::set_var("OUT_DIR", &out_dir);

        match option_env!("TEST_THRIFT") {
            Some(thrift_bin) if env::var("THRIFT").is_err() => env::set_var("THRIFT", thrift_bin),
            _ => (),
        }

        Config::from_env().context("Failed to create thrift compiler")?
    };

    compiler
        .base_path(&input_dir)
        .run(input_files.into_iter().map(|file| input_dir.join(file)))
        .context("Failed to run thrift")?;

    fs::read_to_string(out_dir.join("lib.rs")).context("Failed reading lib.rs from out dir")
}

fn run_thrift_expect(
    input_files: &[impl AsRef<Path>],
    cratemap: Option<&str>,
    files: &[(impl AsRef<Path>, impl AsRef<str>)],
) -> String {
    run_thrift(input_files, cratemap, files).expect("Failed to run thrift")
}

fn regex_assert_lines(
    text: impl AsRef<str>,
    expected_ordered_rgxs: impl IntoIterator<Item = impl AsRef<str>>,
) {
    let text = text.as_ref();
    let mut where_at = 0;
    for rgx in expected_ordered_rgxs {
        let rgx = {
            let rgx = rgx.as_ref();
            Regex::new(rgx.as_ref()).expect(&format!("Failed to compile regex from {}", rgx))
        };

        let rgx_match = rgx.find_at(text, where_at).expect(&format!(
            "Failed to find regex '{}' starting from location {} in text\n---\n{}\n---",
            rgx, where_at, text
        ));
        where_at = rgx_match.end();
    }
}

fn ensure_is_prefixed(
    text: impl AsRef<str>,
    searched_text: impl AsRef<str>,
    prefix: impl AsRef<str>,
) {
    let text = text.as_ref();
    let prefix = prefix.as_ref();
    for rgx_match in Regex::new(searched_text.as_ref()).unwrap().find_iter(text) {
        let start = rgx_match.start();
        assert_eq!(
            &text[start - prefix.len()..start],
            prefix,
            "Expected to find prefix {} ending at position {} in text\n---{}\n---",
            prefix,
            start,
            text
        );
    }
}

static GENERATED_THRIFT_HEADER: &'static str = concat!(
    "// @",
    "generated by Thrift. This file is probably not the place you want to edit!"
);
static PUB_MOD_TYPES: &'static str = "pub mod types {";

fn match_line_expression(line: &str) -> String {
    if cfg!(windows) {
        // See https://github.com/rust-lang/regex/issues/244
        format!("(?m)^{}\r?$", escape(line))
    } else {
        format!("(?m)^{}$", escape(line))
    }
}

#[test]
fn one_file() {
    regex_assert_lines(
        run_thrift_expect(
            &["one.thrift"],
            None,
            &[(
                "one.thrift",
                r#"struct Example {
1: i64 field,
}
"#,
            )],
        ),
        &[
            &match_line_expression(GENERATED_THRIFT_HEADER),
            &match_line_expression(PUB_MOD_TYPES),
            &escape("pub struct Example {"),
        ],
    )
}

#[test]
fn many_files() {
    let result = run_thrift_expect(
        &["one.thrift", "two.thrift"],
        Some(
            r#"one _ crate
two _ crate
"#,
        ),
        &[
            (
                "one.thrift",
                r#"struct Example {
1: i64 field,
}
"#,
            ),
            (
                "two.thrift",
                r#"include "one.thrift"
struct Example2 {
1: one.Example field2,
}
"#,
            ),
        ],
    );

    regex_assert_lines(
        &result,
        &[
            &match_line_expression("pub mod one {"),
            &match_line_expression(GENERATED_THRIFT_HEADER),
            &match_line_expression(PUB_MOD_TYPES),
            &escape("pub struct Example {"),
            &match_line_expression("pub mod two {"),
            &match_line_expression(PUB_MOD_TYPES),
            &escape("pub struct Example2 {"),
            &escape("pub field2: crate::one::types::Example,"),
        ],
    );

    ensure_is_prefixed(result, r"\bone::", "crate::");
}

#[test]
fn include() {
    let result = run_thrift_expect(
        &["one.thrift"],
        Some(
            r#"sub_one _ subdir
sub_two _ subdir
one _ crate
"#,
        ),
        &[
            (
                "one.thrift",
                r#"include "subdir/sub_one.thrift"
  include "subdir/sub_two.thrift"
  struct Example {
  1: sub_one.Example2 field12,
  2: sub_two.Example3 field13,
  }
  "#,
            ),
            (
                "subdir/sub_one.thrift",
                r#"struct Example2 {
  1: i64 field2,
  }
  "#,
            ),
            (
                "subdir/sub_two.thrift",
                r#"struct Example3 {
  1: i64 field3,
  }
  "#,
            ),
        ],
    );

    regex_assert_lines(
        &result,
        &[
            &match_line_expression(GENERATED_THRIFT_HEADER),
            &match_line_expression(PUB_MOD_TYPES),
            &escape("pub struct Example {"),
            &escape("pub field12: ::subdir::sub_one::types::Example2,"),
            &escape("pub field13: ::subdir::sub_two::types::Example3,"),
        ],
    );

    ensure_is_prefixed(&result, r"\bsub_one::", "::subdir::");
    ensure_is_prefixed(result, r"\bsub_two::", "::subdir::");
}
